/* File:        $Id$
 * Revision:    $Revision$
 * Author:      $Author$
 * Date:        $Date$
 *
 * The Netarchive Suite - Software to harvest and preserve websites
 * Copyright 2004-2007 Det Kongelige Bibliotek and Statsbiblioteket, Denmark
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

package dk.netarkivet.harvester.datamodel;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import dk.netarkivet.common.exceptions.ArgumentNotValid;
import dk.netarkivet.common.exceptions.IOFailure;
import dk.netarkivet.common.exceptions.PermissionDenied;
import dk.netarkivet.common.exceptions.UnknownID;
import dk.netarkivet.common.utils.FilterIterator;
import dk.netarkivet.common.utils.StringUtils;

import java.sql.Clob;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * A database-based implementation of the DomainDAO.
 *
 * Statements to create the tables are in
 * scripts/sql/createfullhddb.sql
 */

public class DomainDBDAO extends DomainDAO {
    /** The log. */
    private final Log log = LogFactory.getLog(getClass());

    /** Creates a database-based implementation of the DomainDAO.
     * Will check that all schemas have correct versions, and update the ones
     * that haven't.
     * @throws IOFailure on trouble updating tables to new versions, or on
     * tables with wrong versions that we don't know how to change to expected
     * version.
     */
    protected DomainDBDAO() {
        DBConnect.checkTableVersion("domains", 2);
        DBConnect.checkTableVersion("configurations", 3);
        DBConnect.checkTableVersion("config_passwords", 1);
        DBConnect.checkTableVersion("config_seedlists", 1);
        DBConnect.checkTableVersion("seedlists", 1);
        DBConnect.checkTableVersion("passwords", 1);
        DBConnect.checkTableVersion("ownerinfo", 1);
        DBConnect.checkTableVersion("historyinfo", 2);
    }

    /** Create a new domain in the DB.
     * @see DomainDAO#create(Domain)
     */
    public synchronized void create(Domain d) {
        ArgumentNotValid.checkNotNull(d, "d");
        ArgumentNotValid.checkNotNullOrEmpty(d.getName(), "d.getName()");

        if (exists(d.getName())) {
            String msg = "Cannot create already existing domain " + d;
            log.debug(msg);
            throw new PermissionDenied(msg);
        }

        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        log.debug("trying to create domain with name: " + d.getName());
        try {
            c.setAutoCommit(false);
            s = c.prepareStatement("INSERT INTO domains "
                    + "(name, comments, defaultconfig, crawlertraps, edition,"
                    + " alias, lastaliasupdate ) "
                    + "VALUES ( ?, ?, -1, ?, ?, ?, ? )",
                    Statement.RETURN_GENERATED_KEYS);
            // Id is autogenerated
            // defaultconfig cannot exist yet, so we put in -1
            // until we have configs
            DBConnect.setName(s, 1, d);
            DBConnect.setComments(s, 2, d);
            DBConnect.setStringMaxLength(s, 3,
                    StringUtils.conjoin("\n",d.getCrawlerTraps() ),
                    Constants.MAX_CRAWLER_TRAP_SIZE, d, "crawlertraps");
            long initialEdition = 1;
            s.setLong(4, initialEdition);
            AliasInfo aliasInfo = d.getAliasInfo();
            DBConnect.setLongMaybeNull(s, 5, aliasInfo == null ?
                    null : DBConnect.selectLongValue(
                            "SELECT domain_id FROM domains WHERE name = ?",
                            aliasInfo.getAliasOf()));
            DBConnect.setDateMaybeNull(s, 6, aliasInfo == null ?
                                             null : aliasInfo.getLastChange());
            s.executeUpdate();

            d.setID(DBConnect.getGeneratedID(s));
            s.close();

            Iterator<Password> passwords = d.getAllPasswords();
            while (passwords.hasNext()) {
                Password p = passwords.next();
                insertPassword(d, p);
            }

            Iterator<SeedList> seedlists = d.getAllSeedLists();
            if (!seedlists.hasNext()) {
                String msg = "No seedlists for domain " + d;
                log.debug(msg);
                throw new ArgumentNotValid(msg);
            }
            while (seedlists.hasNext()) {
                SeedList sl = seedlists.next();
                insertSeedlist(d, sl);
            }

            Iterator<DomainConfiguration> dcs = d.getAllConfigurations();
            if (!dcs.hasNext()) {
                String msg = "No configurations for domain " + d;
                log.debug(msg);
                throw new ArgumentNotValid(msg);
            }
            while (dcs.hasNext()) {
                DomainConfiguration dc = dcs.next();
                insertConfiguration(d, dc);

                // Create xref tables for seedlists referenced by this config
                createConfigSeedlistsEntries(d, dc);

                // Create xref tables for passwords referenced by this config
                createConfigPasswordsEntries(d, dc);
            }

            // Now that configs are defined, set the default config.
            s = c.prepareStatement("UPDATE domains SET defaultconfig = "
                    + "(SELECT config_id FROM configurations "
                    + "WHERE configurations.name = ? AND configurations.domain_id = ?) "
                    + "WHERE domain_id = ?");
            DBConnect.setName(s, 1, d.getDefaultConfiguration());
            s.setLong(2, d.getID());
            s.setLong(3, d.getID());
            s.executeUpdate();
            s.close();
            for (Iterator<HarvestInfo> hi = d.getHistory().getHarvestInfo();
                    hi.hasNext(); ) {
                insertHarvestInfo(d, hi.next());
            }

            for (DomainOwnerInfo doi : d.getAllDomainOwnerInfo()) {
                insertOwnerInfo(d, doi);
            }

            c.commit();
            d.setEdition(initialEdition);
        } catch (SQLException e) {
            String message = "SQL error creating domain " + d + " in database";
            log.warn(message, e);
            throw new IOFailure(message, e);
        } finally {
            DBConnect.rollbackIfNeeded(c, "creating", d);
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Change an existing domain in the DB.
     * @see DomainDAO#update(Domain)
     */
    public synchronized void update(Domain d) {
        ArgumentNotValid.checkNotNull(d, "domain");

        if (!exists(d.getName())) {
            throw new UnknownID("No domain named " + d.getName() + " exists");
        }
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            c.setAutoCommit(false);
            // Domain object may not have ID yet, so get it from the DB
            long domainID = DBConnect.selectLongValue(
                "SELECT domain_id FROM domains WHERE name = ?", d.getName());
            if (d.hasID() && d.getID() != domainID) {
                String message = "Domain " + d + " has wrong id: Has "
                    + d.getID() + ", but persistent store claims " + domainID;
                log.warn(message);
                throw new ArgumentNotValid(message);
            }
            d.setID(domainID);

            // The alias field is now updated using a separate select request rather
            // than embedding the select inside the update statement.
            // This change was needed to accomodate MySQL, and may lower performance.
            s = c.prepareStatement("UPDATE domains SET "
                    + "comments = ?, crawlertraps = ?, edition = ?,"
                    + "alias = ?, lastAliasUpdate = ? "
                    + "WHERE domain_id = ? AND edition = ?");
            DBConnect.setComments(s, 1, d);
            DBConnect.setStringMaxLength(s, 2,
                    StringUtils.conjoin("\n",d.getCrawlerTraps() ),
                    Constants.MAX_CRAWLER_TRAP_SIZE, d, "crawlertraps");

            final long newEdition = d.getEdition() + 1;
            s.setLong(3, newEdition);
            AliasInfo aliasInfo = d.getAliasInfo();
            DBConnect.setLongMaybeNull(s, 4, aliasInfo == null ?
                    null : DBConnect.selectLongValue(
                            "SELECT domain_id FROM domains WHERE name = ?",
                            aliasInfo.getAliasOf()));
            DBConnect.setDateMaybeNull(s, 5, aliasInfo == null ?
                                             null : aliasInfo.getLastChange());
            s.setLong(6, d.getID());
            s.setLong(7, d.getEdition());
            int rows = s.executeUpdate();
            if (rows == 0) {
                String message = "Edition " + d.getEdition()
                        + " has expired, cannot update " + d;
                log.debug(message);
                throw new PermissionDenied(message);
            }
            s.close();

            updatePasswords(d);

            updateSeedlists(d);

            updateConfigurations(d);

            updateOwnerInfo(d);

            updateHarvestInfo(d);

            // Now that configs are updated, we can set default_config
            s = c.prepareStatement("UPDATE domains SET "
                    + "defaultconfig = (SELECT config_id"
                    + "                 FROM configurations"
                    + "                 WHERE domain_id = ?"
                    + "                   AND name = ?)"
                    + " WHERE domain_id = ?");
            s.setLong(1, d.getID());
            s.setString(2, d.getDefaultConfiguration().getName());
            s.setLong(3, d.getID());
            s.executeUpdate();
            c.commit();
            d.setEdition(newEdition);
        } catch (SQLException e) {
            String message = "SQL error updating domain " + d + " in database";
            log.warn(message, e);
            throw new IOFailure(message, e);
        } finally {
            DBConnect.rollbackIfNeeded(c, "updating", d);
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Update the list of passwords for the given domain, keeping IDs
     * where applicable.
     *
     * @param d A domain to update.
     * @throws SQLException
     */
    private void updatePasswords(Domain d)
            throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            Map<String,Long> oldNames = DBConnect.selectStringLongMap("SELECT name, password_id FROM passwords " +
                    "WHERE domain_id = ?", d.getID());
            s = c.prepareStatement("UPDATE passwords SET "
                    + "comments = ?, "
                    + "url = ?, "
                    + "realm = ?, "
                    + "username = ?, "
                    + "password = ? "
                    + "WHERE name = ? AND domain_id = ?");
            for (Iterator<Password> pwds = d.getAllPasswords(); pwds.hasNext(); ) {
                Password pwd = pwds.next();
                if (oldNames.containsKey(pwd.getName())) {
                    DBConnect.setComments(s, 1, pwd);
                    DBConnect.setStringMaxLength(s, 2, pwd.getPasswordDomain(),
                            Constants.MAX_URL_SIZE, pwd, "password url");
                    DBConnect.setStringMaxLength(s, 3, pwd.getRealm(),
                            Constants.MAX_REALM_NAME_SIZE, pwd,
                            "password realm");
                    DBConnect.setStringMaxLength(s, 4, pwd.getUsername(),
                            Constants.MAX_USER_NAME_SIZE, pwd,
                            "password username");
                    DBConnect.setStringMaxLength(s, 5, pwd.getPassword(),
                            Constants.MAX_PASSWORD_SIZE, pwd, "password");
                    s.setString(6, pwd.getName());
                    s.setLong(7, d.getID());
                    s.executeUpdate();
                    s.clearParameters();
                    pwd.setID(oldNames.get(pwd.getName()));
                    oldNames.remove(pwd.getName());
                } else {
                    insertPassword(d, pwd);
                }
            }
            s.close();
            s = c.prepareStatement("DELETE FROM passwords " +
                    "WHERE password_id = ?");
            for (Long gone : oldNames.values()) {
                // Check that we're not deleting something that's in use
                // Since deletion is very rare, this is allowed to take some time.
                String usages = DBConnect.getUsages("SELECT configurations.name"
                        + "  FROM configurations, config_passwords"
                        + " WHERE configurations.config_id = config_passwords.config_id"
                        + "   AND config_passwords.password_id = ?", gone, gone);
                if (usages != null) {
                    String name = DBConnect.selectStringValue("SELECT name"
                            + " FROM passwords WHERE password_id = ?", gone);
                    String message = "Cannot delete password " + name
                            + " as it is used in " + usages;
                    log.debug(message);
                    throw new PermissionDenied(message);
                }
                s.setLong(1, gone);
                s.executeUpdate();
                s.clearParameters();
            }
        } finally{
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Update the list of seedlists for the given domain, keeping IDs
     * where applicable.
     *
     * @param d A domain to update.
     * @throws SQLException
     */
    private void updateSeedlists(Domain d)
            throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        Map<String,Long> oldNames;

        try {
            oldNames = DBConnect.selectStringLongMap("SELECT name, seedlist_id FROM seedlists "
                    + "WHERE domain_id = ?", d.getID());
            s = c.prepareStatement("UPDATE seedlists SET "
                    + "comments = ?, "
                    + "seeds = ? "
                    + "WHERE name = ? AND domain_id = ?");
            for (Iterator<SeedList> sls = d.getAllSeedLists(); sls.hasNext(); ) {
                SeedList sl = sls.next();
                if (oldNames.containsKey(sl.getName())) {
                    DBConnect.setComments(s, 1, sl);
                    DBConnect.setClobMaxLength(s, 2, sl.getSeedsAsString(), Constants.MAX_SEED_LIST_SIZE, sl, "seedlist");
                    s.setString(3, sl.getName());
                    s.setLong(4, d.getID());
                    s.executeUpdate();
                    s.clearParameters();
                    sl.setID(oldNames.get(sl.getName()));
                    oldNames.remove(sl.getName());
                } else {
                    insertSeedlist(d, sl);
                }
            }
            s.close();
            s = c.prepareStatement("DELETE FROM seedlists "
                    + "WHERE seedlist_id = ?");
            for (Long gone : oldNames.values()) {
                // Check that we're not deleting something that's in use
                // Since deletion is very rare, this is allowed to take some time.
                String usages = DBConnect.getUsages("SELECT configurations.name"
                        + "  FROM configurations, config_seedlists"
                        + " WHERE configurations.config_id = config_seedlists.config_id"
                        + "   AND config_seedlists.seedlist_id = ?", gone, gone);
                if (usages != null) {
                    String name = DBConnect.selectStringValue("SELECT name"
                            + " FROM seedlists WHERE seedlist_id = ?", gone);
                    String message = "Cannot delete seedlist " + name
                            + " as it is used in " + usages;
                    log.debug(message);
                    throw new PermissionDenied(message);
                }
                s.setLong(1, gone);
                s.executeUpdate();
                s.clearParameters();
            }
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Update the list of configurations for the given domain, keeping IDs
     * where applicable.  This also builds the xref tables for passwords and
     * seedlists used in configurations, and so should be run after those are
     * updated.
     *
     * @param d A domain to update.
     * @throws SQLException
     */
    private void updateConfigurations(Domain d)
            throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        Map<String,Long> oldNames;

        try {
            oldNames = DBConnect.selectStringLongMap("SELECT name, config_id FROM configurations "
                    + "WHERE domain_id = ?", d.getID());
            s = c.prepareStatement("UPDATE configurations SET "
                    + "comments = ?, "
                    + "template_id = ( SELECT template_id FROM ordertemplates WHERE name = ? ), "
                    + "maxobjects = ?, "
                    + "maxrate = ?, "
                    + "maxbytes = ? "
                    + "WHERE name = ? AND domain_id = ?");
            for (Iterator<DomainConfiguration> dcs = d.getAllConfigurations();
                 dcs.hasNext(); ) {
                DomainConfiguration dc = dcs.next();

                if (oldNames.containsKey(dc.getName())) {
                    // Update
                    DBConnect.setComments(s, 1, dc);
                    s.setString(2, dc.getOrderXmlName());
                    s.setInt(3, dc.getMaxObjects());
                    s.setInt(4, dc.getMaxRequestRate());
                    s.setLong(5, dc.getMaxBytes());
                    s.setString(6, dc.getName());
                    s.setLong(7, d.getID());
                    s.executeUpdate();
                    s.clearParameters();
                    dc.setID(oldNames.get(dc.getName()));
                    oldNames.remove(dc.getName());
                } else {
                    insertConfiguration(d, dc);
                }

                updateConfigPasswordsEntries(d, dc);
                updateConfigSeedlistsEntries(d, dc);
            }
            s.close();
            s = c.prepareStatement("DELETE FROM configurations "
                    + "WHERE config_id = ?");
            for (Long gone : oldNames.values()) {
                // Before deleting, check if this is unused.  Since deletion is
                // rare, this is allowed to take some time to give good output
                String usages = DBConnect.getUsages("SELECT harvestdefinitions.name"
                        + "  FROM harvestdefinitions, harvest_configs"
                        + " WHERE harvestdefinitions.harvest_id = harvest_configs.harvest_id"
                        + "   AND harvest_configs.config_id = ?", gone, gone);
                if (usages != null) {
                    String name = DBConnect.selectStringValue(
                            "SELECT name FROM configurations WHERE config_id = ?", gone);
                    String message = "Cannot delete configuration " + name
                            + " as it is used in " + usages;
                    log.debug(message);
                    throw new PermissionDenied(message);
                }
                deleteConfigFromTable(gone, "config_seedlists");
                deleteConfigFromTable(gone, "config_passwords");
                s.setLong(1, gone);
                s.executeUpdate();
                s.clearParameters();
            }
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Update the list of owner info for the given domain, keeping IDs
     * where applicable.
     *
     * @param d A domain to update.
     * @throws SQLException
     */
    private void updateOwnerInfo(Domain d)
            throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;

        try {
            List<Long> oldIDs = DBConnect.selectLongList("SELECT ownerinfo_id FROM ownerinfo "
                    + "WHERE domain_id = ?", d.getID());
            s = c.prepareStatement("UPDATE ownerinfo SET "
                    + "created = ?, "
                    + "info = ? "
                    + "WHERE ownerinfo_id = ?");
            for (DomainOwnerInfo doi : d.getAllDomainOwnerInfo()) {
                if (doi.hasID() && oldIDs.remove(doi.getID())) {
                    s.setTimestamp(1, new Timestamp(doi.getDate().getTime()));
                    DBConnect.setStringMaxLength(s, 2, doi.getInfo(),
                            Constants.MAX_OWNERINFO_SIZE, doi, "owner info");
                    s.setLong(3, doi.getID());
                    s.executeUpdate();
                    s.clearParameters();
                } else {
                    insertOwnerInfo(d, doi);
                }
            }
            if (oldIDs.size() != 0) {
                String message = "Not allowed to delete ownerinfo " + oldIDs
                        + " on " + d;
                log.debug(message);
                throw new IOFailure(message);
            }
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Update the list of harvest info for the given domain, keeping IDs
     * where applicable.
     *
     * @param d A domain to update.
     * @throws SQLException
     */
    private void updateHarvestInfo(Domain d)
            throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;

        try {
            List<Long> oldIDs;

            oldIDs = DBConnect.selectLongList("SELECT historyinfo.historyinfo_id "
                    + "FROM historyinfo, configurations "
                    + "WHERE historyinfo.config_id = configurations.config_id"
                    + "  AND configurations.domain_id = ?", d.getID());
            s = c.prepareStatement("UPDATE historyinfo SET "
                    + "stopreason = ?, "
                    + "objectcount = ?, "
                    + "bytecount = ?, "
                    + "config_id = "
                    + " (SELECT config_id FROM configurations, domains"
                    + "  WHERE domains.domain_id = ?"
                    + "    AND configurations.name = ?"
                    + "    AND configurations.domain_id = domains.domain_id), "
                    + "harvest_id = ?, "
                    + "job_id = ? "
                    + "WHERE historyinfo_id = ?");
            Iterator<HarvestInfo> his = d.getHistory().getHarvestInfo();
            while (his.hasNext()) {
                HarvestInfo hi = his.next();
                if (hi.hasID() && oldIDs.remove(hi.getID())) {
                    s.setInt(1, hi.getStopReason().ordinal());
                    s.setLong(2, hi.getCountObjectRetrieved());
                    s.setLong(3, hi.getSizeDataRetrieved());
                    s.setLong(4, d.getID());
                    s.setString(5, d.getConfiguration(hi.getDomainConfigurationName()).getName());
                    s.setLong(6, hi.getHarvestID());
                    if (hi.getJobID() != null) {
                        s.setLong(7, hi.getJobID());
                    } else {
                        s.setNull(7, Types.BIGINT);
                    }
                    s.setLong(8, hi.getID());
                    s.executeUpdate();
                    s.clearParameters();
                } else {
                    insertHarvestInfo(d, hi);
                }
            }
            if (oldIDs.size() != 0) {
                String message = "Not allowed to delete historyinfo " + oldIDs
                        + " on " + d;
                log.debug(message);
                throw new IOFailure(message);
            }
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Insert new harvest info for a domain.
     *
     * @param d A domain to insert on.  The domains ID must be correct.
     * @param harvestInfo Harvest info to insert.
     */
    private void insertHarvestInfo(Domain d, HarvestInfo harvestInfo) {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            // Note that the config_id is grabbed from the configurations table.
            s = c.prepareStatement("INSERT INTO historyinfo "
                    + "( stopreason, objectcount, bytecount, config_id, job_id, "
                    + "harvest_id, harvest_time ) "
                    + "VALUES ( ?, ?, ?, ?, ?, ?, ? )",
                    Statement.RETURN_GENERATED_KEYS);
            s.setInt(1, harvestInfo.getStopReason().ordinal());
            s.setLong(2, harvestInfo.getCountObjectRetrieved());
            s.setLong(3, harvestInfo.getSizeDataRetrieved());
            // TODO: More stable way to get IDs, use a select
            s.setLong(4, d.getConfiguration(harvestInfo.getDomainConfigurationName()).getID());
            if (harvestInfo.getJobID() != null) {
                s.setLong(5, harvestInfo.getJobID());
            } else {
                s.setNull(5, Types.BIGINT);
            }
            s.setLong(6, harvestInfo.getHarvestID());
            s.setTimestamp(7, new Timestamp(harvestInfo.getDate().getTime()));
            s.executeUpdate();
            harvestInfo.setID(DBConnect.getGeneratedID(s));
        } catch (SQLException e) {
            throw new IOFailure("SQL error while inserting harvest info "
                    + harvestInfo + " for " + d, e);
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Insert new owner info for a domain.
     *
     * @param d A domain to insert on.  The domains ID must be correct.
     * @param doi Owner info to insert.
     * @throws SQLException
     */
    private void insertOwnerInfo(Domain d, DomainOwnerInfo doi) throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            s = c.prepareStatement("INSERT INTO ownerinfo "
                    + "( domain_id, created, info ) VALUES ( ?, ?, ?)",
                    Statement.RETURN_GENERATED_KEYS);
            s.setLong(1, d.getID());
            s.setTimestamp(2, new Timestamp(doi.getDate().getTime()));
            s.setString(3, doi.getInfo());
            s.executeUpdate();
            doi.setID(DBConnect.getGeneratedID(s));
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Insert new seedlist for a domain.
     *
     * @param d A domain to insert on.  The domains ID must be correct.
     * @param sl Seedlist to insert.
     * @throws SQLException
     */
    private void insertSeedlist(Domain d, SeedList sl) throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            s = c.prepareStatement("INSERT INTO seedlists "
                    + "( name, comments, domain_id, seeds ) VALUES ( ?, ?, ?, ? )",
                    Statement.RETURN_GENERATED_KEYS);
            // ID is autogenerated
            DBConnect.setName(s, 1, sl);
            DBConnect.setComments(s, 2, sl);
            s.setLong(3, d.getID());
            DBConnect.setClobMaxLength(s, 4, sl.getSeedsAsString(), Constants.MAX_SEED_LIST_SIZE, sl, "seedlist");
            s.executeUpdate();
            sl.setID(DBConnect.getGeneratedID(s));
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Inserts a new password entry into the database.
     *
     * @param d A domain to insert on.  The domains ID must be correct.
     * @param p A password entry to insert.
     * @throws SQLException
     */
    private void insertPassword(Domain d, Password p) throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            s = c.prepareStatement("INSERT INTO passwords "
                    + "( name, comments, domain_id, url, realm, username, password ) "
                    + "VALUES ( ?, ?, ?, ?, ?, ?, ? )",
                    Statement.RETURN_GENERATED_KEYS);
            // ID is autogenerated
            DBConnect.setName(s, 1, p);
            DBConnect.setComments(s, 2, p);
            s.setLong(3, d.getID());
            DBConnect.setStringMaxLength(s, 4, p.getPasswordDomain(),
                    Constants.MAX_URL_SIZE, p, "password url");
            DBConnect.setStringMaxLength(s, 5, p.getRealm(),
                    Constants.MAX_REALM_NAME_SIZE, p, "password realm");
            DBConnect.setStringMaxLength(s, 6, p.getUsername(),
                    Constants.MAX_USER_NAME_SIZE, p, "password username");
            DBConnect.setStringMaxLength(s, 7, p.getPassword(),
                    Constants.MAX_PASSWORD_SIZE, p, "password");
            s.executeUpdate();
            p.setID(DBConnect.getGeneratedID(s));
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Insert the basic configuration info into the DB.
     * This does not establish the connections with seedlists and passwords,
     * use {create,update}Config{Passwords,Seedlists}Entries for that.
     *
     * @param d
     * @param dc
     * @throws SQLException
     */
    private void insertConfiguration(Domain d, DomainConfiguration dc) throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            long template_id = DBConnect.selectLongValue("SELECT template_id FROM ordertemplates WHERE name = ?", dc.getOrderXmlName());
            s = c.prepareStatement("INSERT INTO configurations "
                    + "( name, comments, domain_id, template_id, maxobjects, maxrate, maxbytes ) "
                    + "VALUES ( ?, ?, ?, ?, ?, ?, ?)",
                    Statement.RETURN_GENERATED_KEYS);
            // Id is autogenerated
            DBConnect.setName(s, 1, dc);
            DBConnect.setComments(s, 2, dc);
            s.setLong(3, d.getID());
            s.setLong(4, template_id);
            s.setInt(5, dc.getMaxObjects());
            s.setInt(6, dc.getMaxRequestRate());
            s.setLong(7, dc.getMaxBytes());
            int rows = s.executeUpdate();
            if (rows != 1) {
                String message = "Error inserting configuration " + dc;
                log.warn(message);
                throw new IOFailure(message);
            }
            dc.setID(DBConnect.getGeneratedID(s));
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Delete all entries in the given crossref table that belong to the
     * configuration.
     * @param config_id The domain configuration to remove entries for.
     * @param table One of "config_passwords" or "config_seedlists"
     * @throws SQLException
     */
    private void deleteConfigFromTable(long config_id,
                                       String table)
            throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            s = c.prepareStatement("DELETE FROM " + table
                    + " WHERE " + table + ".config_id = ?");
            s.setLong(1, config_id);
            s.executeUpdate();
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Delete all entries from the config_passwords table that refer to
     * the given configuration and insert the current ones.
     * @param d A domain to operate on
     * @param dc Configuration to update.
     * @throws SQLException
     */
    private void updateConfigPasswordsEntries(Domain d, DomainConfiguration dc)
            throws SQLException {
        deleteConfigFromTable(dc.getID(), "config_passwords");
        createConfigPasswordsEntries(d, dc);
    }

    /** Create the xref table for passwords used by configurations.
     *
     * @param d A domain to operate on.
     * @param dc A configuration to create xref table for.
     * @throws SQLException
     */
    private void createConfigPasswordsEntries(Domain d, DomainConfiguration dc)
            throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            s = c.prepareStatement("INSERT INTO config_passwords "
                    + "( config_id, password_id ) "
                    + "SELECT config_id, password_id "
                    + "  FROM configurations, passwords"
                    + " WHERE configurations.domain_id = ?"
                    + "   AND configurations.name = ?"
                    + "   AND passwords.name = ?"
                    + "   AND passwords.domain_id = configurations.domain_id");
            for (Iterator<Password> passwords = dc.getPasswords();
                 passwords.hasNext(); ) {
                Password p = passwords.next();
                s.setLong(1, d.getID());
                s.setString(2, dc.getName());
                s.setString(3, p.getName());
                s.executeUpdate();
                s.clearParameters();
            }
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Delete all entries from the config_seedlists table that refer to
     * the given configuration and insert the current ones.
     * @param d A domain to operate on
     * @param dc Configuration to update.
     * @throws SQLException
     */
    private void updateConfigSeedlistsEntries(Domain d, DomainConfiguration dc)
            throws SQLException {
        deleteConfigFromTable(dc.getID(), "config_seedlists");
        createConfigSeedlistsEntries(d, dc);
    }

    /** Create the xref table for seedlists used by configurations.
     *
     * @param d A domain to operate on.
     * @param dc A configuration to create xref table for.
     * @throws SQLException
     */
    private void createConfigSeedlistsEntries(Domain d, DomainConfiguration dc)
            throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            s = c.prepareStatement("INSERT INTO config_seedlists "
                    + " ( config_id, seedlist_id ) "
                    + "SELECT configurations.config_id, seedlists.seedlist_id"
                    + "  FROM configurations, seedlists"
                    + " WHERE configurations.name = ?"
                    + "   AND seedlists.name = ?"
                    + "   AND configurations.domain_id = ?"
                    + "   AND seedlists.domain_id = ?");
            for (Iterator<SeedList> seedlists = dc.getSeedLists();
                 seedlists.hasNext(); ) {
                SeedList sl = seedlists.next();
                s.setString(1, dc.getName());
                s.setString(2, sl.getName());
                s.setLong(3, d.getID());
                s.setLong(4, d.getID());
                s.executeUpdate();
                s.clearParameters();
            }
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Read a domain from the database
     *
     * @see DomainDAO#read(String)
     */
    public synchronized Domain read(String domainName) {
        if (!exists(domainName)) {
            throw new UnknownID("No domain by the name '" + domainName + "'");
        }
        Domain result;
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            s = c.prepareStatement("SELECT domains.domain_id, "
                    + "domains.comments, "
                    + "domains.crawlertraps, "
                    + "domains.edition, "
                    + "configurations.name, "
                    + " (SELECT name FROM domains as aliasdomains"
                    + "  WHERE aliasdomains.domain_id = domains.alias), "
                    + "domains.lastaliasupdate "
                    + "FROM domains, configurations "
                    + "WHERE domains.name = ?"
                    + "  AND domains.defaultconfig = configurations.config_id");
            s.setString(1, domainName);
            ResultSet res = s.executeQuery();
            if (!res.next()) {
                final String message = "Error reading existing domain '"
                                        + domainName + "'";
                log.warn(message);
                throw new IOFailure(message);
            }
            int domainId = res.getInt(1);
            String comments = res.getString(2);
            String crawlertraps = res.getString(3);
            long edition = res.getLong(4);
            String defaultconfig = res.getString(5);
            String alias = res.getString(6);
            Date lastAliasUpdate = DBConnect.getDateMaybeNull(res, 7);
            s.close();
            Domain d = new Domain(domainName);
            d.setComments(comments);
            d.setCrawlerTraps(Arrays.asList(crawlertraps.split("\n")));
            d.setID(domainId);
            d.setEdition(edition);
            if (alias != null) {
                d.setAliasInfo(new AliasInfo(domainName,alias,lastAliasUpdate));
            }

            readSeedlists(d);
            readPasswords(d);
            readConfigurations(d);
            // Now that configs are in, we can set the default
            d.setDefaultConfiguration(defaultconfig);
            readOwnerInfo(d);
            readHistoryInfo(d);

            result = d;
        } catch (SQLException e) {
            throw new IOFailure("SQL Error while reading domain " + domainName, e);
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }

        return result;
    }

    /** Read the configurations for the domain.
     * This should not be called until after passwords and seedlists
     * are read.
     * @param d The domain being read.  Its ID must be set.
     * @throws SQLException If database errors occur.
     */
    private void readConfigurations(Domain d) throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        PreparedStatement s1 = null;
        ResultSet res;
        // Read the configurations now that passwords and seedlists exist
        try {
            s = c.prepareStatement("SELECT "
                    + "config_id, "
                    + "configurations.name, "
                    + "comments, "
                    + "ordertemplates.name, "
                    + "maxobjects, "
                    + "maxrate, "
                    + "maxbytes"
                    + " FROM configurations, ordertemplates "
                    + "WHERE domain_id = ?"
                    + "  AND configurations.template_id = ordertemplates.template_id");
            s.setLong(1, d.getID());
            res = s.executeQuery();
            while (res.next()) {
                long dc_id = res.getLong(1);
                String dc_name = res.getString(2);
                String dc_comments = res.getString(3);
                String order = res.getString(4);
                int maxobjects = res.getInt(5);
                int maxrate = res.getInt(6);
                long maxbytes = res.getLong(7);
                s1 = c.prepareStatement(
                        "SELECT seedlists.name FROM seedlists, config_seedlists "
                        + "WHERE config_seedlists.config_id = ? "
                        + "AND config_seedlists.seedlist_id = seedlists.seedlist_id");
                s1.setLong(1, dc_id);
                ResultSet seedlist_res = s1.executeQuery();
                List<SeedList> seedlists = new ArrayList<SeedList>();
                while (seedlist_res.next()) {
                    seedlists.add(d.getSeedList(seedlist_res.getString(1)));
                }
                s1.close();
                if (seedlists.isEmpty()) {
                    String message = "Configuration " + dc_name + " of " + d
                            + " has no seedlists";
                    log.warn(message);
                    throw new IOFailure(message);
                }

                s1 = c.prepareStatement(
                        "SELECT passwords.name FROM passwords, config_passwords "
                        + "WHERE config_passwords.config_id = ? "
                        + "AND config_passwords.password_id = passwords.password_id");
                s1.setLong(1, dc_id);
                ResultSet password_res = s1.executeQuery();
                List<Password> passwords = new ArrayList<Password>();
                while (password_res.next()) {
                    passwords.add(d.getPassword(password_res.getString(1)));
                }
                DomainConfiguration dc =
                        new DomainConfiguration(dc_name, d, seedlists, passwords);
                dc.setOrderXmlName(order);
                dc.setMaxObjects(maxobjects);
                dc.setMaxRequestRate(maxrate);
                dc.setComments(dc_comments);
                dc.setMaxBytes(maxbytes);
                dc.setID(dc_id);
                d.addConfiguration(dc);
                s1.close();
            }
            if (!d.getAllConfigurations().hasNext()) {
                String message = "Loaded domain " + d + " with no configurations";
                log.warn(message);
                throw new IOFailure(message);
            }
        } finally {
            DBConnect.closeStatementIfOpen(s);
            DBConnect.closeStatementIfOpen(s1);
        }
    }

    /** Read owner info entries for the domain.
     * @param d The domain being read.  Its ID must be set.
     * @throws SQLException If database errors occur.
     */
    private void readOwnerInfo(Domain d) throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        ResultSet res;
        // Read owner info
        try {
            s = c.prepareStatement("SELECT ownerinfo_id, created, info"
                    + " FROM ownerinfo WHERE domain_id = ?");
            s.setLong(1, d.getID());
            res = s.executeQuery();
            while (res.next()) {
                final DomainOwnerInfo ownerinfo = new DomainOwnerInfo(new Date(res.getTimestamp(2).getTime()),
                        res.getString(3));
                ownerinfo.setID(res.getLong(1));
                d.addOwnerInfo(ownerinfo);
            }
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Read history info entries for the domain.
     * @param d The domain being read.  Its ID must be set.
     * @throws SQLException If database errors occur.
     */
    private void readHistoryInfo(Domain d)
            throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        ResultSet res;
        // Read history info
        try {
            s = c.prepareStatement("SELECT historyinfo_id, stopreason, "
                    + "objectcount, bytecount, "
                    + "name, job_id, harvest_id, harvest_time "
                    + "FROM historyinfo, configurations "
                    + "WHERE configurations.domain_id = ?"
                    + "  AND historyinfo.config_id = configurations.config_id");
            s.setLong(1, d.getID());
            res = s.executeQuery();
            while (res.next()) {
                long hiID = res.getLong(1);
                int stopreasonNum = res.getInt(2);
                StopReason stopreason = StopReason.getStopReason(stopreasonNum);
                long objectCount = res.getLong(3);
                long byteCount = res.getLong(4);
                String config_name = res.getString(5);
                Long job_id = res.getLong(6);
                if (res.wasNull()) {
                    job_id = null;
                }
                long harvest_id = res.getLong(7);
                Date harvest_time = new Date(res.getTimestamp(8).getTime());
                HarvestInfo hi;
                // XML DAOs didn't keep the job id in harvestinfo, so some
                // entries will be null.
                hi = new HarvestInfo(harvest_id, job_id, d.getName(), config_name,
                        harvest_time, byteCount, objectCount, stopreason);
                hi.setID(hiID);
                d.getHistory().addHarvestInfo(hi);
            }
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Read passwords for the domain.
     * @param d The domain being read.  Its ID must be set.
     * @throws SQLException If database errors occur.
     */
    private void readPasswords(Domain d) throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        ResultSet res;
        // Read the passwords
        try {
            s = c.prepareStatement("SELECT password_id, name, comments, url, realm, username, password "
                    + "FROM passwords WHERE domain_id = ?");
            s.setLong(1, d.getID());
            res = s.executeQuery();
            while (res.next()) {
                final Password pwd = new Password(res.getString(2),
                        res.getString(3), res.getString(4), res.getString(5),
                        res.getString(6), res.getString(7));
                pwd.setID(res.getLong(1));
                d.addPassword(pwd);
            }
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Read seedlists for the domain.
     *
     * @param d The domain being read.  Its ID must be set.
     * @throws SQLException If database errors occur.
     */
    private void readSeedlists(Domain d) throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        ResultSet res;
        // Read the seedlists
        try {
            s = c.prepareStatement("SELECT seedlist_id, name, comments, seeds"
                    + " FROM seedlists WHERE domain_id = ?");
            s.setLong(1, d.getID());
            res = s.executeQuery();
            while (res.next()) {
                final long sl_id = res.getLong(1);
                final String seedlistName = res.getString(2);
                String sl_comments = res.getString(3);
                Clob clob = res.getClob(4);
                String seedlistContents = clob.getSubString(1, (int)clob.length());
                final SeedList seedlist =
                        new SeedList(seedlistName, seedlistContents);
                seedlist.setComments(sl_comments);
                seedlist.setID(sl_id);
                d.addSeedList(seedlist);
            }
            s.close();
            if (!d.getAllSeedLists().hasNext()) {
                final String msg = "Domain " + d + " loaded with no seedlists";
                log.warn(msg);
                throw new IOFailure(msg);
            }
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Return true if a domain with the given name exists.
     * @see DomainDAO#exists(String)
     */
    public synchronized boolean exists(String domainName) {
        ArgumentNotValid.checkNotNullOrEmpty(domainName, "domainName");

       return 1 == DBConnect.selectIntValue(
               "SELECT COUNT(*) FROM domains WHERE name = ?", domainName);
    }

    /** Return a string indicating what uses there are of the domain,
     * or null if the domain has no uses that prevent it from being deleted.
     * Notice that this is not a light-weight function.
     *
     * @param domainName a given domain name.
     * @return the above mentioned usage-string.
     */
    public String describeUsages(String domainName) {
        long id = DBConnect.selectLongValue("SELECT domain_id FROM domains WHERE name = ?", domainName);
        return describeUsages(domainName, id);
    }

    /** Utility method to get the actual usages of a domain.
     *
     * @param domainName a given domainName
     * @param id The ID for the domain with the given domainName
     * @return a String describing the usage of this domain.
     */
    private synchronized String describeUsages(String domainName, long id) {
        String hdusages = DBConnect.getUsages("SELECT harvestdefinitions.name "
                + "FROM harvest_configs, configurations, harvestdefinitions "
                + "WHERE harvest_configs.config_id = configurations.config_id"
                + "  AND configurations.domain_id = ?"
                + "  AND harvest_configs.harvest_id = harvestdefinitions.harvest_id",
                domainName, id);
        int harvestCount = DBConnect.selectIntValue("SELECT COUNT(*)"
                + "  FROM historyinfo, configurations"
                + " WHERE historyinfo.config_id = configurations.config_id"
                + "   AND configurations.domain_id = ?",
                id);
        if (hdusages != null && harvestCount != 0) {
            return hdusages + ", historical info from  "
                    + harvestCount + " harvests";
        } else if (hdusages != null) {
            return hdusages;
        } else if (harvestCount != 0) {
            return "Historical info from " + harvestCount + " harvests";
        } else {
            return null;
        }
    }

    /** Delete a domain from the database.
     * @see DomainDAO#delete(String)
     */
    public synchronized void delete(String domainName) {
        ArgumentNotValid.checkNotNullOrEmpty(domainName, "domainName");

        if (!exists(domainName)) {
            throw new UnknownID("No domain found with id " + domainName);
        }

        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            c.setAutoCommit(false);
            long id = DBConnect.selectLongValue("SELECT domain_id FROM domains WHERE name = ?", domainName);
            String uses = describeUsages(domainName, id);
            if (uses != null) {
                throw new PermissionDenied("Can't delete domain " + domainName
                        + " as it is used by the following: " + uses);
            }
            List<Long> config_ids = DBConnect.selectLongList("SELECT config_id FROM configurations WHERE domain_id = ?", id);
            for (long config_id : config_ids) {
                deleteConfigFromTable(config_id, "config_seedlists");
                deleteConfigFromTable(config_id, "config_passwords");
                deleteConfigFromTable(config_id, "historyinfo");
            }
            for (String tableName : new String[] {
                "domains", "configurations", "seedlists", "passwords"
            }) {
                deleteDomainFromTable(id, tableName);
            }
            log.debug("Deleting domain " + domainName);
            c.commit();
        } catch (SQLException e) {
            String message = "SQL error deleting domain " + domainName + " in database";
            log.warn(message, e);
            throw new IOFailure(message, e);
        } finally {
            DBConnect.rollbackIfNeeded(c, "deleting", domainName);
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Delete references to a domain from a table with column domain_id.
     *
     * @param id Domain ID to delete references to.
     * @param table Table to delete from.
     * @throws SQLException
     */
    private void deleteDomainFromTable(long id, String table)
            throws SQLException {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            s = c.prepareStatement("DELETE FROM " + table + " WHERE domain_id = ?");
            s.setLong(1, id);
            s.executeUpdate();
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    /** Get the total number of domains in the database.
     * @see DomainDAO#getCountDomains()
     */
    public synchronized int getCountDomains() {
        return DBConnect.selectIntValue("SELECT COUNT(*) FROM domains");
    }

    /** Get a list of all domains.
     * Warning: This will build a string list of the domains, which will
     * be rather long in a full system.
     * @see DomainDAO#getAllDomains()
     */
    public synchronized Iterator<Domain> getAllDomains() {
        try {
            List<String> domainNames = DBConnect.selectStringlist(
                    "SELECT name FROM domains ORDER BY name");
            return new FilterIterator<String, Domain>(domainNames.iterator()) {
                public Domain filter(String s) {
                    return read(s);
                }
            };
        } catch (SQLException e) {
            String message = "SQL error asking for all domains in database";
            log.warn(message, e);
            throw new IOFailure(message, e);
        }
    }

    /** Get a list of all domains in snapshot harvest order.
     * Warning: This will build a string list of the domains, which will
     * be rather long in a full system.
     * @see DomainDAO#getAllDomainsInSnapshotHarvestOrder()
     */
    public Iterator<Domain> getAllDomainsInSnapshotHarvestOrder() {
        try {
            //Note: maxbytes are ordered with largest first for symmetry
            //with HarvestDefinition.CompareConfigDesc
            List<String> domainNames = DBConnect.selectStringlist(
                "SELECT domains.name"
                + " FROM domains, configurations, ordertemplates"
                + " WHERE domains.defaultconfig=configurations.config_id"
                + " AND configurations.template_id=ordertemplates.template_id"
                + " ORDER BY"
                + " ordertemplates.name,"
                + " configurations.maxbytes DESC,"
                + " domains.name");
            return new FilterIterator<String, Domain>(domainNames.iterator()) {
                public Domain filter(String s) {
                    return read(s);
                }
            };
        } catch (SQLException e) {
            String message = "SQL error asking for all domains in database";
            log.warn(message, e);
            throw new IOFailure(message, e);
        }
    }

    /**
     * Close down any connections used by the DAO.
     */
    public void close() {
        try {
            DBConnect.getDBConnection().close();
        } catch (SQLException e) {
            String message = "SQL error closing Domain DAO DB connection";
            log.warn(message, e);
            throw new IOFailure(message, e);
        }
    }

    public List<String> getDomains(String glob) {
        // SQL uses % and _ instead of * and ?
        String sqlGlob = DBConnect.makeSQLGlob(glob);
        try {
            return DBConnect.selectStringlist("SELECT name FROM domains WHERE name LIKE ?",
                    sqlGlob);
        } catch (SQLException e) {
            String message = "SQL error searching for domains with glob "
                + glob;
            log.warn(message, e);
            throw new IOFailure(message, e);
        }
    }

    public int getCountDomains(String glob) {
        // SQL uses % and _ instead of * and ?
        String sqlGlob = DBConnect.makeSQLGlob(glob);
        return DBConnect.selectIntValue(
                    "SELECT count(name) FROM domains WHERE name LIKE ?",
                    sqlGlob);
    }

    public List<DomainHarvestInfo> getDomainHarvestInfo(String domainName) {
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        final ArrayList<DomainHarvestInfo> domainHarvestInfos =
                new ArrayList<DomainHarvestInfo>();
        try {
            // For historical reasons, not all historyinfo objects have the
            // information required to find the job that made them.  Therefore,
            // we must left outer join them onto the jobs list to get the
            // start date and end date for those where they can be found.
            s = c.prepareStatement("SELECT jobs.job_id, hdname, hdid,"
                    + " harvest_num,"
                    + " configname, startdate,"
                    + " enddate, objectcount, bytecount, stopreason"
                    + " FROM ( "
                    + "  SELECT harvestdefinitions.name AS hdname,"
                    + "         harvestdefinitions.harvest_id AS hdid,"
                    + "         configurations.name AS configname,"
                    + "         objectcount, bytecount, job_id, stopreason"
                    + "    FROM domains, configurations, historyinfo, "
                    + "         harvestdefinitions"
                    + "   WHERE domains.name = ? "
                    + "     AND domains.domain_id = configurations.domain_id"
                    + "     AND historyinfo.config_id = configurations.config_id"
                    + "     AND historyinfo.harvest_id = harvestdefinitions.harvest_id"
                    + "  ) AS hist"
                    + " LEFT OUTER JOIN jobs"
                    + "   ON hist.job_id = jobs.job_id");
            s.setString(1, domainName);
            ResultSet res = s.executeQuery();
            while (res.next()) {
                final int jobID = res.getInt(1);
                final String harvestName = res.getString(2);
                final int harvestID = res.getInt(3);
                final int harvestNum = res.getInt(4);
                final String configName = res.getString(5);
                final Date startDate = DBConnect.getDateMaybeNull(res, 6);
                final Date endDate = DBConnect.getDateMaybeNull(res, 7);
                final long objectCount = res.getLong(8);
                final long byteCount = res.getLong(9);
                final StopReason reason
                        = StopReason.getStopReason(res.getInt(10));
                domainHarvestInfos.add(new DomainHarvestInfo(
                        domainName, jobID, harvestName, harvestID, harvestNum, configName,
                        startDate, endDate, byteCount, objectCount, reason));
            }
            return domainHarvestInfos;
        } catch (SQLException e) {
            String message = "SQL error getting domain harvest info for "
                + domainName;
            log.warn(message, e);
            throw new IOFailure(message, e);
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
    }

    public boolean mayDelete(DomainConfiguration config) {
        // Never delete default config
        return config != config.getDomain().getDefaultConfiguration()
               && !DBConnect.selectAny("SELECT config_id"
                                       + " FROM harvest_configs"
                                       + " WHERE config_id = ?",
                                       config.getID());
    }

    public boolean mayDelete(SeedList seedlist) {
        return !DBConnect.selectAny("SELECT seedlist_id"
                + " FROM config_seedlists WHERE seedlist_id = ?",
                seedlist.getID());
    }

    public boolean mayDelete(Password password) {
        return !DBConnect.selectAny("SELECT password_id"
                + " FROM config_passwords WHERE password_id = ?",
                password.getID());
    }

    public boolean mayDelete(Domain domain) {
        return !DBConnect.selectAny(
                "SELECT *"
                + "  FROM historyinfo, configurations"
                + " WHERE historyinfo.config_id = configurations.config_id"
                + "   AND configurations.domain_id = ?",
                domain.getID())
               && !DBConnect.selectAny(
                "SELECT * FROM harvest_configs, configurations"
                + " WHERE configurations.domain_id = ?"
                + "   AND harvest_configs.config_id = configurations.config_id",
                domain.getID());
    }

    /**
     * Read a Domain from Database, and return the domain information as a
     * SparseDomain object. We only read information relevant for the GUI
     * listing.
     *
     * @param domainName a given domain
     * @return a SparseDomain.
     * @throws ArgumentNotValid if domainName is null or empty.
     * @throws UnknownID if domain does not exist
     */
    public synchronized SparseDomain readSparse(String domainName) {
        ArgumentNotValid.checkNotNullOrEmpty(domainName, "domainName");
        try {
            List<String> domainConfigurationNames
                    = DBConnect.selectStringlist("SELECT configurations.name "
                        + " FROM configurations, domains "
                        + "WHERE domains.domain_id = configurations.domain_id "
                        + " AND domains.name = ?", domainName);
            if (domainConfigurationNames.size() == 0) {
                throw new UnknownID("No domain exists with name '"
                                    + domainName + "'");
            }
            return new SparseDomain(domainName, domainConfigurationNames);
        } catch (SQLException e) {
            throw new IOFailure("SQL Error while reading domain " + domainName,
                                e);
        }
    }

    /**
     * @see DomainDAO#getAliases(String)
     */
    public List<AliasInfo> getAliases(String domain) {
        ArgumentNotValid.checkNotNullOrEmpty(domain, "String domain");
        List<AliasInfo> resultSet = new ArrayList<AliasInfo>();
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        // return all <domain, alias, lastaliasupdate> tuples
        // where alias = domain
        if (!exists(domain)) {
            log.debug("domain named '" + domain
                     + "' does not exist. Returning empty result set");
            return resultSet;
        }
        try {
            s = c.prepareStatement("SELECT domains.name, "
                                   + "domains.lastaliasupdate "
                    + " FROM domains, domains as fatherDomains "
                    + " WHERE domains.alias = fatherDomains.domain_id AND"
                    + "       fatherDomains.name = ?"
                    + " ORDER BY domains.name");
            s.setString(1, domain);
            ResultSet res = s.executeQuery();
            while (res.next()) {
                AliasInfo ai = new AliasInfo(res.getString(1),
                        domain,
                        DBConnect.getDateMaybeNull(res, 2));
                resultSet.add(ai);
            }
        } catch (SQLException e) {
            throw new IOFailure("Failure getting alias-information", e);
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
        return resultSet;
    }

    /**
     * @see DomainDAO#getAllAliases()
     */
    public List<AliasInfo> getAllAliases() {
        List<AliasInfo> resultSet = new ArrayList<AliasInfo>();
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        // return all <domain, alias, lastaliasupdate> tuples
        // where alias is not-null
        try {
            s = c.prepareStatement("SELECT domains.name, "
                                   + "(SELECT name FROM domains as aliasdomains"
                                   + " WHERE aliasdomains.domain_id "
                                   + "= domains.alias), "
                                   + " domains.lastaliasupdate "
                                   + " FROM domains "
                                   + " WHERE domains.alias IS NOT NULL"
                                   + " ORDER BY "
                                   + " lastaliasupdate ASC");
            ResultSet res = s.executeQuery();
            while (res.next()) {
                String domainName = res.getString(1);
                String aliasOf = res.getString(2);
                Date lastchanged = DBConnect.getDateMaybeNull(res, 3);
                AliasInfo ai = new AliasInfo(domainName, aliasOf, lastchanged);
                resultSet.add(ai);
            }
        } catch (SQLException e) {
            throw new IOFailure("Failure getting alias-information", e);
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
        return resultSet;
    }

    /**
     * Return all TLDs represented by the domains in the domains table.
     * @see DomainDAO#getTLDs()
     */
    public List<TLDInfo> getTLDs() {
        Map<String, TLDInfo> resultMap = new HashMap<String, TLDInfo>();
        Connection c = DBConnect.getDBConnection();
        PreparedStatement s = null;
        try {
            s = c.prepareStatement("SELECT name FROM domains");
            ResultSet res = s.executeQuery();
            while (res.next()) {
                String domain = res.getString(1);
                String tld = TLDInfo.getTLD(domain);
                TLDInfo i = resultMap.get(tld);
                if (i == null) {
                    i = new TLDInfo(tld);
                    resultMap.put(tld, i);
                }
                i.addSubdomain(domain);
            }
        } catch (SQLException e) {
            throw new IOFailure("Failure getting TLD-information", e);
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
        List<TLDInfo> resultSet = new ArrayList<TLDInfo>(resultMap.values());
        Collections.sort(resultSet);
        return resultSet;
    }

    /**
     * @see DomainDAO#getDomainJobInfo(Job, String, String)
     */
    public HarvestInfo getDomainJobInfo(Job j, String domainName, String configName) {
        ArgumentNotValid.checkNotNull(j, "j");
        ArgumentNotValid.checkNotNullOrEmpty(domainName, "domainName");
        ArgumentNotValid.checkNotNullOrEmpty(configName, "configName");
        HarvestInfo resultInfo = null;
        Connection c = DBConnect.getDBConnection();
        // Get domain_id for domainName
        long domainId = DBConnect.selectLongValue(
                "SELECT domain_id FROM domains WHERE name=?", domainName);
        PreparedStatement s = null;
        try {
            s = c.prepareStatement("SELECT stopreason, "
                    + "objectcount, bytecount, "
                    + "harvest_time FROM historyinfo WHERE "
                    + "job_id = ? AND "
                    + "config_id = ? AND "
                    + "harvest_id = ?");
            s.setLong(1, j.getJobID());
            s.setLong(2, DBConnect.selectLongValue(
                    "SELECT config_id FROM configurations WHERE name = ? AND domain_id=?",
                    configName, domainId));
            s.setLong(3, j.getOrigHarvestDefinitionID());
            ResultSet res = s.executeQuery();
            // If no result, the job may not have been run yet
            // return null HarvestInfo
            if (res.next()) {
                StopReason reason = StopReason.getStopReason(res.getInt(1));
                long objectCount = res.getLong(2);
                long byteCount = res.getLong(3);
                Date harvestTime = res.getDate(4);
                resultInfo = new HarvestInfo(j.getOrigHarvestDefinitionID(), j.getJobID(),
                        domainName, configName, harvestTime,
                        byteCount, objectCount, reason);
            }
        } catch (SQLException e) {
            throw new IOFailure("Failure getting DomainJobInfo", e);
        } finally {
            DBConnect.closeStatementIfOpen(s);
        }
        return resultInfo;
    }

}